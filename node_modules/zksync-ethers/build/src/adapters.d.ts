import { BigNumberish, BlockTag, BytesLike, ethers, TransactionRequest as EthersTransactionRequest } from "ethers";
import { Provider } from "./provider";
import { IL1Bridge, IL2Bridge, IZkSync } from "../typechain";
import { Address, BalancesMap, Eip712Meta, FullDepositFee, PriorityOpResponse, TransactionResponse } from "./types";
type Constructor<T = {}> = new (...args: any[]) => T;
interface TxSender {
    sendTransaction(tx: EthersTransactionRequest): Promise<ethers.TransactionResponse>;
    getAddress(): Promise<Address>;
}
export declare function AdapterL1<TBase extends Constructor<TxSender>>(Base: TBase): {
    new (...args: any[]): {
        _providerL2(): Provider;
        _providerL1(): ethers.Provider;
        _signerL1(): ethers.Signer;
        getMainContract(): Promise<IZkSync>;
        getL1BridgeContracts(): Promise<{
            erc20: IL1Bridge;
            weth: IL1Bridge;
        }>;
        getBalanceL1(token?: Address, blockTag?: BlockTag): Promise<bigint>;
        getAllowanceL1(token: Address, bridgeAddress?: Address, blockTag?: ethers.BlockTag): Promise<bigint>;
        l2TokenAddress(token: Address): Promise<string>;
        approveERC20(token: Address, amount: BigNumberish, overrides?: ethers.Overrides & {
            bridgeAddress?: Address;
        }): Promise<ethers.TransactionResponse>;
        getBaseCost(params: {
            gasLimit: BigNumberish;
            gasPerPubdataByte?: BigNumberish;
            gasPrice?: BigNumberish;
        }): Promise<bigint>;
        deposit(transaction: {
            token: Address;
            amount: BigNumberish;
            to?: Address;
            operatorTip?: BigNumberish;
            bridgeAddress?: Address;
            approveERC20?: boolean;
            l2GasLimit?: BigNumberish;
            gasPerPubdataByte?: BigNumberish;
            refundRecipient?: Address;
            overrides?: ethers.Overrides;
            approveOverrides?: ethers.Overrides;
            customBridgeData?: BytesLike;
        }): Promise<PriorityOpResponse>;
        estimateGasDeposit(transaction: {
            token: Address;
            amount: BigNumberish;
            to?: Address;
            operatorTip?: BigNumberish;
            bridgeAddress?: Address;
            customBridgeData?: BytesLike;
            l2GasLimit?: BigNumberish;
            gasPerPubdataByte?: BigNumberish;
            refundRecipient?: Address;
            overrides?: ethers.Overrides;
        }): Promise<bigint>;
        getDepositTx(transaction: {
            token: Address;
            amount: BigNumberish;
            to?: Address;
            operatorTip?: BigNumberish;
            bridgeAddress?: Address;
            l2GasLimit?: BigNumberish;
            gasPerPubdataByte?: BigNumberish;
            customBridgeData?: BytesLike;
            refundRecipient?: Address;
            overrides?: ethers.Overrides;
        }): Promise<any>;
        getFullRequiredDepositFee(transaction: {
            token: Address;
            to?: Address;
            bridgeAddress?: Address;
            customBridgeData?: BytesLike;
            gasPerPubdataByte?: BigNumberish;
            overrides?: ethers.Overrides;
        }): Promise<FullDepositFee>;
        _getWithdrawalLog(withdrawalHash: BytesLike, index?: number): Promise<{
            log: import("./types").Log;
            l1BatchTxId: number | null;
        }>;
        _getWithdrawalL2ToL1Log(withdrawalHash: BytesLike, index?: number): Promise<{
            l2ToL1LogIndex: number;
            l2ToL1Log: import("./types").L2ToL1Log;
        }>;
        finalizeWithdrawalParams(withdrawalHash: BytesLike, index?: number): Promise<{
            l1BatchNumber: number | null;
            l2MessageIndex: number;
            l2TxNumberInBlock: number | null;
            message: any;
            sender: string;
            proof: string[];
        }>;
        finalizeWithdrawal(withdrawalHash: BytesLike, index?: number, overrides?: ethers.Overrides): Promise<ethers.ContractTransactionResponse>;
        isWithdrawalFinalized(withdrawalHash: BytesLike, index?: number): Promise<boolean>;
        claimFailedDeposit(depositHash: BytesLike, overrides?: ethers.Overrides): Promise<ethers.ContractTransactionResponse>;
        requestExecute(transaction: {
            contractAddress: Address;
            calldata: string;
            l2GasLimit: BigNumberish;
            l2Value?: BigNumberish;
            factoryDeps?: ethers.BytesLike[];
            operatorTip?: BigNumberish;
            gasPerPubdataByte?: BigNumberish;
            refundRecipient?: Address;
            overrides?: ethers.Overrides;
        }): Promise<PriorityOpResponse>;
        estimateGasRequestExecute(transaction: {
            contractAddress: Address;
            calldata: string;
            l2GasLimit?: BigNumberish;
            l2Value?: BigNumberish;
            factoryDeps?: ethers.BytesLike[];
            operatorTip?: BigNumberish;
            gasPerPubdataByte?: BigNumberish;
            refundRecipient?: Address;
            overrides?: ethers.Overrides;
        }): Promise<bigint>;
        getRequestExecuteTx(transaction: {
            contractAddress: Address;
            calldata: string;
            l2GasLimit?: BigNumberish;
            l2Value?: BigNumberish;
            factoryDeps?: ethers.BytesLike[];
            operatorTip?: BigNumberish;
            gasPerPubdataByte?: BigNumberish;
            refundRecipient?: Address;
            overrides?: ethers.Overrides;
        }): Promise<EthersTransactionRequest>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & TBase;
export declare function AdapterL2<TBase extends Constructor<TxSender>>(Base: TBase): {
    new (...args: any[]): {
        _providerL2(): Provider;
        _signerL2(): ethers.Signer;
        getBalance(token?: Address, blockTag?: BlockTag): Promise<bigint>;
        getAllBalances(): Promise<BalancesMap>;
        getDeploymentNonce(): Promise<bigint>;
        getL2BridgeContracts(): Promise<{
            erc20: IL2Bridge;
            weth: IL2Bridge;
        }>;
        _fillCustomData(data: Eip712Meta): Eip712Meta;
        withdraw(transaction: {
            token: Address;
            amount: BigNumberish;
            to?: Address;
            bridgeAddress?: Address;
            overrides?: ethers.Overrides;
        }): Promise<TransactionResponse>;
        transfer(transaction: {
            to: Address;
            amount: BigNumberish;
            token?: Address;
            overrides?: ethers.Overrides;
        }): Promise<TransactionResponse>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & TBase;
export {};
