"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Provider_connect, _BrowserProvider_request;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserProvider = exports.Provider = exports.JsonRpcApiProvider = void 0;
const ethers_1 = require("ethers");
const typechain_1 = require("../typechain");
const types_1 = require("./types");
const utils_1 = require("./utils");
const signer_1 = require("./signer");
const format_1 = require("./format");
function JsonRpcApiProvider(ProviderType) {
    return class Provider extends ProviderType {
        _send(payload) {
            throw new Error("Must be implemented by the derived class!");
        }
        contractAddresses() {
            throw new Error("Must be implemented by the derived class!");
        }
        _getBlockTag(blockTag) {
            if (blockTag == "committed") {
                return "committed";
            }
            return super._getBlockTag(blockTag);
        }
        _wrapLog(value, network) {
            return new types_1.Log((0, format_1.formatLog)(value), this);
        }
        _wrapBlock(value, network) {
            const block = (0, format_1.formatBlock)(value);
            return new types_1.Block(super._wrapBlock(block, network), this);
        }
        _wrapTransactionResponse(value, network) {
            const tx = (0, format_1.formatTransactionResponse)(value);
            return new types_1.TransactionResponse(super._wrapTransactionResponse(tx, network), this);
        }
        _wrapTransactionReceipt(value, network) {
            const receipt = (0, format_1.formatTransactionReceipt)(value);
            return new types_1.TransactionReceipt(receipt, this);
        }
        async getTransactionReceipt(txHash) {
            while (true) {
                const receipt = await super.getTransactionReceipt(txHash);
                if (receipt && receipt.blockNumber) {
                    return receipt;
                }
                await (0, utils_1.sleep)(500);
            }
        }
        async getTransaction(txHash) {
            return (await super.getTransaction(txHash));
        }
        async getBlock(blockHashOrBlockTag, includeTxs) {
            return (await super.getBlock(blockHashOrBlockTag, includeTxs));
        }
        async getLogs(filter) {
            return (await super.getLogs(filter));
        }
        async getBalance(address, blockTag, tokenAddress) {
            if (tokenAddress == null || (0, utils_1.isETH)(tokenAddress)) {
                // requesting ETH balance
                return await super.getBalance(address, blockTag);
            }
            else {
                try {
                    let token = typechain_1.IERC20__factory.connect(tokenAddress, this);
                    return await token.balanceOf(address, { blockTag });
                }
                catch {
                    return 0n;
                }
            }
        }
        async l2TokenAddress(token) {
            if (token == utils_1.ETH_ADDRESS) {
                return utils_1.ETH_ADDRESS;
            }
            else {
                const bridgeAddresses = await this.getDefaultBridgeAddresses();
                const l2WethBridge = typechain_1.IL2Bridge__factory.connect(bridgeAddresses.wethL2, this);
                try {
                    const l2WethToken = await l2WethBridge.l2TokenAddress(token);
                    if (l2WethToken != ethers_1.ethers.ZeroAddress) {
                        return l2WethToken;
                    }
                }
                catch (e) { }
                const erc20Bridge = typechain_1.IL2Bridge__factory.connect(bridgeAddresses.erc20L2, this);
                return await erc20Bridge.l2TokenAddress(token);
            }
        }
        async l1TokenAddress(token) {
            if (token == utils_1.ETH_ADDRESS) {
                return utils_1.ETH_ADDRESS;
            }
            else {
                const bridgeAddresses = await this.getDefaultBridgeAddresses();
                const l2WethBridge = typechain_1.IL2Bridge__factory.connect(bridgeAddresses.wethL2, this);
                try {
                    const l1WethToken = await l2WethBridge.l1TokenAddress(token);
                    if (l1WethToken != ethers_1.ethers.ZeroAddress) {
                        return l1WethToken;
                    }
                }
                catch (e) { }
                const erc20Bridge = typechain_1.IL2Bridge__factory.connect(bridgeAddresses.erc20L2, this);
                return await erc20Bridge.l1TokenAddress(token);
            }
        }
        async estimateGasL1(transaction) {
            return await this.send("zks_estimateGasL1ToL2", [this.getRpcTransaction(transaction)]);
        }
        async estimateFee(transaction) {
            return await this.send("zks_estimateFee", [transaction]);
        }
        async getGasPrice() {
            const feeData = await this.getFeeData();
            return feeData.gasPrice;
        }
        async getLogProof(txHash, index) {
            return await this.send("zks_getL2ToL1LogProof", [ethers_1.ethers.hexlify(txHash), index]);
        }
        async getL1BatchBlockRange(l1BatchNumber) {
            const range = await this.send("zks_getL1BatchBlockRange", [l1BatchNumber]);
            if (range == null) {
                return null;
            }
            return [parseInt(range[0], 16), parseInt(range[1], 16)];
        }
        async getMainContractAddress() {
            if (!this.contractAddresses().mainContract) {
                this.contractAddresses().mainContract = await this.send("zks_getMainContract", []);
            }
            return this.contractAddresses().mainContract;
        }
        async getTestnetPaymasterAddress() {
            // Unlike contract's addresses, the testnet paymaster is not cached, since it can be trivially changed
            // on the fly by the server and should not be relied on to be constant
            return await this.send("zks_getTestnetPaymaster", []);
        }
        async getDefaultBridgeAddresses() {
            if (!this.contractAddresses().erc20BridgeL1) {
                let addresses = await this.send("zks_getBridgeContracts", []);
                this.contractAddresses().erc20BridgeL1 = addresses.l1Erc20DefaultBridge;
                this.contractAddresses().erc20BridgeL2 = addresses.l2Erc20DefaultBridge;
                this.contractAddresses().wethBridgeL1 = addresses.l1WethBridge;
                this.contractAddresses().wethBridgeL2 = addresses.l2WethBridge;
            }
            return {
                erc20L1: this.contractAddresses().erc20BridgeL1,
                erc20L2: this.contractAddresses().erc20BridgeL2,
                wethL1: this.contractAddresses().wethBridgeL1,
                wethL2: this.contractAddresses().wethBridgeL2,
            };
        }
        async getConfirmedTokens(start = 0, limit = 255) {
            const tokens = await this.send("zks_getConfirmedTokens", [start, limit]);
            return tokens.map((token) => ({ address: token.l2Address, ...token }));
        }
        async getAllAccountBalances(address) {
            let balances = await this.send("zks_getAllAccountBalances", [address]);
            for (let token in balances) {
                balances[token] = BigInt(balances[token]);
            }
            return balances;
        }
        async l1ChainId() {
            const res = await this.send("zks_L1ChainId", []);
            return Number(res);
        }
        async getL1BatchNumber() {
            const number = await this.send("zks_L1BatchNumber", []);
            return Number(number);
        }
        async getL1BatchDetails(number) {
            return await this.send("zks_getL1BatchDetails", [number]);
        }
        async getBlockDetails(number) {
            return await this.send("zks_getBlockDetails", [number]);
        }
        async getTransactionDetails(txHash) {
            return await this.send("zks_getTransactionDetails", [txHash]);
        }
        async getBytecodeByHash(bytecodeHash) {
            return await this.send("zks_getBytecodeByHash", [bytecodeHash]);
        }
        async getRawBlockTransactions(number) {
            return await this.send("zks_getRawBlockTransactions", [number]);
        }
        async getWithdrawTx(transaction) {
            var _a;
            const { ...tx } = transaction;
            if (tx.to == null && tx.from == null) {
                throw new Error("withdrawal target address is undefined");
            }
            tx.to ?? (tx.to = tx.from);
            tx.overrides ?? (tx.overrides = {});
            (_a = tx.overrides).from ?? (_a.from = tx.from);
            if ((0, utils_1.isETH)(tx.token)) {
                if (!tx.overrides.value) {
                    tx.overrides.value = tx.amount;
                }
                const passedValue = BigInt(tx.overrides.value);
                if (passedValue != BigInt(tx.amount)) {
                    // To avoid users shooting themselves into the foot, we will always use the amount to withdraw
                    // as the value
                    throw new Error("The tx.value is not equal to the value withdrawn");
                }
                const ethL2Token = typechain_1.IEthToken__factory.connect(utils_1.L2_ETH_TOKEN_ADDRESS, this);
                return ethL2Token.withdraw.populateTransaction(tx.to, tx.overrides);
            }
            if (tx.bridgeAddress == null) {
                const bridgeAddresses = await this.getDefaultBridgeAddresses();
                const l2WethBridge = typechain_1.IL2Bridge__factory.connect(bridgeAddresses.wethL2, this);
                let l1WethToken = ethers_1.ethers.ZeroAddress;
                try {
                    l1WethToken = await l2WethBridge.l1TokenAddress(tx.token);
                }
                catch (e) { }
                tx.bridgeAddress =
                    l1WethToken != ethers_1.ethers.ZeroAddress ? bridgeAddresses.wethL2 : bridgeAddresses.erc20L2;
            }
            const bridge = typechain_1.IL2Bridge__factory.connect(tx.bridgeAddress, this);
            return bridge.withdraw.populateTransaction(tx.to, tx.token, tx.amount, tx.overrides);
        }
        async estimateGasWithdraw(transaction) {
            const withdrawTx = await this.getWithdrawTx(transaction);
            return await this.estimateGas(withdrawTx);
        }
        async getTransferTx(transaction) {
            var _a;
            const { ...tx } = transaction;
            tx.overrides ?? (tx.overrides = {});
            (_a = tx.overrides).from ?? (_a.from = tx.from);
            if (tx.token == null || tx.token == utils_1.ETH_ADDRESS) {
                return {
                    ...tx.overrides,
                    to: tx.to,
                    value: tx.amount,
                };
            }
            else {
                const token = typechain_1.IERC20__factory.connect(tx.token, this);
                return await token.transfer.populateTransaction(tx.to, tx.amount, tx.overrides);
            }
        }
        async estimateGasTransfer(transaction) {
            const transferTx = await this.getTransferTx(transaction);
            return await this.estimateGas(transferTx);
        }
        async newFilter(filter) {
            const id = await this.send("eth_newFilter", [await this._getFilter(filter)]);
            return BigInt(id);
        }
        async newBlockFilter() {
            const id = await this.send("eth_newBlockFilter", []);
            return BigInt(id);
        }
        async newPendingTransactionsFilter() {
            const id = await this.send("eth_newPendingTransactionFilter", []);
            return BigInt(id);
        }
        async getFilterChanges(idx) {
            const logs = await this.send("eth_getFilterChanges", [ethers_1.ethers.toBeHex(idx)]);
            const network = await this.getNetwork();
            return typeof logs[0] === "string"
                ? logs
                : logs.map((log) => this._wrapLog(log, network));
        }
        // This is inefficient. Status should probably be indicated in the transaction receipt.
        async getTransactionStatus(txHash) {
            const tx = await this.getTransaction(txHash);
            if (tx == null) {
                return types_1.TransactionStatus.NotFound;
            }
            if (tx.blockNumber == null) {
                return types_1.TransactionStatus.Processing;
            }
            const verifiedBlock = (await this.getBlock("finalized"));
            if (tx.blockNumber <= verifiedBlock.number) {
                return types_1.TransactionStatus.Finalized;
            }
            return types_1.TransactionStatus.Committed;
        }
        async broadcastTransaction(signedTx) {
            const { blockNumber, hash, network } = await (0, ethers_1.resolveProperties)({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                    method: "broadcastTransaction",
                    signedTransaction: signedTx,
                }),
                network: this.getNetwork(),
            });
            const tx = types_1.Transaction.from(signedTx);
            if (tx.hash !== hash) {
                throw new Error("@TODO: the returned hash did not match");
            }
            return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
        }
        async getL2TransactionFromPriorityOp(l1TxResponse) {
            const receipt = await l1TxResponse.wait();
            const l2Hash = (0, utils_1.getL2HashFromPriorityOp)(receipt, await this.getMainContractAddress());
            let status = null;
            do {
                status = await this.getTransactionStatus(l2Hash);
                await (0, utils_1.sleep)(this.pollingInterval);
            } while (status == types_1.TransactionStatus.NotFound);
            return await this.getTransaction(l2Hash);
        }
        async getPriorityOpResponse(l1TxResponse) {
            const l2Response = { ...l1TxResponse };
            l2Response.waitL1Commit = l2Response.wait;
            l2Response.wait = async () => {
                const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
                return await l2Tx.wait();
            };
            l2Response.waitFinalize = async () => {
                const l2Tx = await this.getL2TransactionFromPriorityOp(l1TxResponse);
                return await l2Tx.waitFinalize();
            };
            return l2Response;
        }
        async getContractAccountInfo(address) {
            const deployerContract = new ethers_1.Contract(utils_1.CONTRACT_DEPLOYER_ADDRESS, utils_1.CONTRACT_DEPLOYER.fragments, this);
            const data = await deployerContract.getAccountInfo(address);
            return {
                supportedAAVersion: data.supportedAAVersion,
                nonceOrdering: data.nonceOrdering,
            };
        }
        // TODO (EVM-3): support refundRecipient for fee estimation
        async estimateL1ToL2Execute(transaction) {
            transaction.gasPerPubdataByte ?? (transaction.gasPerPubdataByte = utils_1.REQUIRED_L1_TO_L2_GAS_PER_PUBDATA_LIMIT);
            // If the `from` address is not provided, we use a random address, because
            // due to storage slot aggregation, the gas estimation will depend on the address
            // and so estimation for the zero address may be smaller than for the sender.
            transaction.caller ?? (transaction.caller = ethers_1.ethers.Wallet.createRandom().address);
            const customData = {
                gasPerPubdata: transaction.gasPerPubdataByte,
            };
            if (transaction.factoryDeps) {
                Object.assign(customData, { factoryDeps: transaction.factoryDeps });
            }
            return await this.estimateGasL1({
                from: transaction.caller,
                data: transaction.calldata,
                to: transaction.contractAddress,
                value: transaction.l2Value,
                customData,
            });
        }
        getRpcTransaction(tx) {
            const result = super.getRpcTransaction(tx);
            if (tx.customData == null) {
                return result;
            }
            result.type = ethers_1.ethers.toBeHex(utils_1.EIP712_TX_TYPE);
            result.eip712Meta = {
                gasPerPubdata: ethers_1.ethers.toBeHex(tx.customData.gasPerPubdata ?? 0),
            };
            if (tx.customData.factoryDeps) {
                result.eip712Meta.factoryDeps = tx.customData.factoryDeps.map((dep) => 
                // TODO (SMA-1605): we arraify instead of hexlifying because server expects Vec<u8>.
                //  We should change deserialization there.
                Array.from(ethers_1.ethers.getBytes(dep)));
            }
            if (tx.customData.paymasterParams) {
                // @ts-ignore
                result.eip712Meta.paymasterParams = {
                    paymaster: ethers_1.ethers.hexlify(tx.customData.paymasterParams.paymaster),
                    paymasterInput: Array.from(ethers_1.ethers.getBytes(tx.customData.paymasterParams.paymasterInput)),
                };
            }
            return result;
        }
    };
}
exports.JsonRpcApiProvider = JsonRpcApiProvider;
class Provider extends JsonRpcApiProvider(ethers_1.ethers.JsonRpcProvider) {
    contractAddresses() {
        return this._contractAddresses;
    }
    constructor(url, network, options) {
        if (url == null) {
            url = "http://localhost:3050";
        }
        super(url, network, options);
        _Provider_connect.set(this, void 0);
        typeof url === "string"
            ? (__classPrivateFieldSet(this, _Provider_connect, new ethers_1.FetchRequest(url), "f"))
            : (__classPrivateFieldSet(this, _Provider_connect, url.clone(), "f"));
        this.pollingInterval = 500;
        this._contractAddresses = {};
    }
    async _send(payload) {
        const request = this._getConnection();
        request.body = JSON.stringify(payload);
        request.setHeader("content-type", "application/json");
        const response = await request.send();
        response.assertOk();
        let resp = response.bodyJson;
        if (!Array.isArray(resp)) {
            resp = [resp];
        }
        return resp;
    }
    static getDefaultProvider(zksyncNetwork = types_1.Network.Localhost) {
        if (process.env.ZKSYNC_WEB3_API_URL) {
            return new Provider(process.env.ZKSYNC_WEB3_API_URL);
        }
        switch (zksyncNetwork) {
            case types_1.Network.Localhost:
                return new Provider("http://localhost:3050");
            case types_1.Network.Goerli:
                return new Provider("https://zksync2-testnet.zksync.dev");
            case types_1.Network.Sepolia:
                return new Provider("https://sepolia.era.zksync.dev");
            case types_1.Network.Mainnet:
                return new Provider("https://mainnet.era.zksync.io");
        }
    }
}
exports.Provider = Provider;
_Provider_connect = new WeakMap();
class BrowserProvider extends JsonRpcApiProvider(ethers_1.ethers.BrowserProvider) {
    contractAddresses() {
        return this._contractAddresses;
    }
    constructor(ethereum, network) {
        super(ethereum, network);
        _BrowserProvider_request.set(this, void 0);
        this._contractAddresses = {};
        __classPrivateFieldSet(this, _BrowserProvider_request, async (method, params) => {
            const payload = { method, params };
            this.emit("debug", { action: "sendEip1193Request", payload });
            try {
                const result = await ethereum.request(payload);
                this.emit("debug", { action: "receiveEip1193Result", result });
                return result;
            }
            catch (e) {
                const error = new Error(e.message);
                error.code = e.code;
                error.data = e.data;
                error.payload = payload;
                this.emit("debug", { action: "receiveEip1193Error", error });
                throw error;
            }
        }, "f");
    }
    async _send(payload) {
        ethers_1.ethers.assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
        try {
            const result = await __classPrivateFieldGet(this, _BrowserProvider_request, "f").call(this, payload.method, payload.params || []);
            return [{ id: payload.id, result }];
        }
        catch (e) {
            return [
                {
                    id: payload.id,
                    error: { code: e.code, data: e.data, message: e.message },
                },
            ];
        }
    }
    getRpcError(payload, error) {
        error = JSON.parse(JSON.stringify(error));
        // EIP-1193 gives us some machine-readable error codes, so rewrite them
        switch (error.error.code || -1) {
            case 4001:
                error.error.message = `ethers-user-denied: ${error.error.message}`;
                break;
            case 4200:
                error.error.message = `ethers-unsupported: ${error.error.message}`;
                break;
        }
        return super.getRpcError(payload, error);
    }
    async hasSigner(address) {
        if (address == null) {
            address = 0;
        }
        const accounts = await this.send("eth_accounts", []);
        if (typeof address === "number") {
            return accounts.length > address;
        }
        address = address.toLowerCase();
        return accounts.filter((a) => a.toLowerCase() === address).length !== 0;
    }
    async getSigner(address) {
        if (address == null) {
            address = 0;
        }
        if (!(await this.hasSigner(address))) {
            try {
                await __classPrivateFieldGet(this, _BrowserProvider_request, "f").call(this, "eth_requestAccounts", []);
            }
            catch (error) {
                const payload = error.payload;
                throw this.getRpcError(payload, { id: payload.id, error });
            }
        }
        return signer_1.Signer.from((await super.getSigner(address)), Number((await this.getNetwork()).chainId));
    }
    async estimateGas(transaction) {
        const gas = await super.estimateGas(transaction);
        const metamaskMinimum = 21000n;
        const isEIP712 = transaction.customData != null || transaction.type == utils_1.EIP712_TX_TYPE;
        return gas > metamaskMinimum || isEIP712 ? gas : metamaskMinimum;
    }
}
exports.BrowserProvider = BrowserProvider;
_BrowserProvider_request = new WeakMap();
