"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Transaction_type, _Transaction_from;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountNonceOrdering = exports.AccountAbstractionVersion = exports.Transaction = exports.Log = exports.Block = exports.TransactionReceipt = exports.TransactionResponse = exports.TransactionStatus = exports.PriorityOpTree = exports.PriorityQueueType = exports.Network = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
// Ethereum network
var Network;
(function (Network) {
    Network[Network["Mainnet"] = 1] = "Mainnet";
    Network[Network["Ropsten"] = 3] = "Ropsten";
    Network[Network["Rinkeby"] = 4] = "Rinkeby";
    Network[Network["Goerli"] = 5] = "Goerli";
    Network[Network["Sepolia"] = 6] = "Sepolia";
    Network[Network["Localhost"] = 9] = "Localhost";
})(Network || (exports.Network = Network = {}));
var PriorityQueueType;
(function (PriorityQueueType) {
    PriorityQueueType[PriorityQueueType["Deque"] = 0] = "Deque";
    PriorityQueueType[PriorityQueueType["HeapBuffer"] = 1] = "HeapBuffer";
    PriorityQueueType[PriorityQueueType["Heap"] = 2] = "Heap";
})(PriorityQueueType || (exports.PriorityQueueType = PriorityQueueType = {}));
var PriorityOpTree;
(function (PriorityOpTree) {
    PriorityOpTree[PriorityOpTree["Full"] = 0] = "Full";
    PriorityOpTree[PriorityOpTree["Rollup"] = 1] = "Rollup";
})(PriorityOpTree || (exports.PriorityOpTree = PriorityOpTree = {}));
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["NotFound"] = "not-found";
    TransactionStatus["Processing"] = "processing";
    TransactionStatus["Committed"] = "committed";
    TransactionStatus["Finalized"] = "finalized";
})(TransactionStatus || (exports.TransactionStatus = TransactionStatus = {}));
class TransactionResponse extends ethers_1.ethers.TransactionResponse {
    constructor(params, provider) {
        super(params, provider);
        this.l1BatchNumber = params.l1BatchNumber;
        this.l1BatchTxIndex = params.l1BatchTxIndex;
    }
    async wait(confirmations) {
        while (true) {
            const receipt = (await super.wait(confirmations));
            if (receipt && receipt.blockNumber) {
                return receipt;
            }
            await (0, utils_1.sleep)(500);
        }
    }
    async getTransaction() {
        return (await super.getTransaction());
    }
    replaceableTransaction(startBlock) {
        return new TransactionResponse(super.replaceableTransaction(startBlock), this.provider);
    }
    async getBlock() {
        return (await super.getBlock());
    }
    async waitFinalize() {
        while (true) {
            const receipt = await this.wait();
            if (receipt && receipt.blockNumber) {
                const block = await this.provider.getBlock("finalized");
                if (receipt.blockNumber <= block.number) {
                    return (await this.provider.getTransactionReceipt(receipt.hash));
                }
            }
            else {
                await (0, utils_1.sleep)(500);
            }
        }
    }
    toJSON() {
        const { l1BatchNumber, l1BatchTxIndex } = this;
        return {
            ...super.toJSON(),
            l1BatchNumber,
            l1BatchTxIndex,
        };
    }
}
exports.TransactionResponse = TransactionResponse;
class TransactionReceipt extends ethers_1.ethers.TransactionReceipt {
    constructor(params, provider) {
        super(params, provider);
        this.l1BatchNumber = params.l1BatchNumber;
        this.l1BatchTxIndex = params.l1BatchTxIndex;
        this.l2ToL1Logs = params.l2ToL1Logs;
        this._logs = Object.freeze(params.logs.map((log) => {
            return new Log(log, provider);
        }));
    }
    get logs() {
        return this._logs;
    }
    getBlock() {
        return super.getBlock();
    }
    getTransaction() {
        return super.getTransaction();
    }
    toJSON() {
        const { l1BatchNumber, l1BatchTxIndex, l2ToL1Logs } = this;
        return {
            ...super.toJSON(),
            l1BatchNumber,
            l1BatchTxIndex,
            l2ToL1Logs,
        };
    }
}
exports.TransactionReceipt = TransactionReceipt;
class Block extends ethers_1.ethers.Block {
    constructor(params, provider) {
        super(params, provider);
        this.l1BatchNumber = params.l1BatchNumber;
        this.l1BatchTimestamp = params.l1BatchTxIndex;
    }
    toJSON() {
        const { l1BatchNumber, l1BatchTimestamp: l1BatchTxIndex } = this;
        return {
            ...super.toJSON(),
            l1BatchNumber,
            l1BatchTxIndex,
        };
    }
    get prefetchedTransactions() {
        return super.prefetchedTransactions;
    }
    getTransaction(indexOrHash) {
        return super.getTransaction(indexOrHash);
    }
}
exports.Block = Block;
class Log extends ethers_1.ethers.Log {
    constructor(params, provider) {
        super(params, provider);
        this.l1BatchNumber = params.l1BatchNumber;
    }
    toJSON() {
        const { l1BatchNumber } = this;
        return {
            ...super.toJSON(),
            l1BatchNumber,
        };
    }
    async getBlock() {
        return (await super.getBlock());
    }
    async getTransaction() {
        return (await super.getTransaction());
    }
    async getTransactionReceipt() {
        return (await super.getTransactionReceipt());
    }
}
exports.Log = Log;
class Transaction extends ethers_1.ethers.Transaction {
    constructor() {
        super(...arguments);
        // super.#type is private and there is no way to override which enforced to
        // introduce following variable
        _Transaction_type.set(this, void 0);
        _Transaction_from.set(this, void 0);
    }
    get type() {
        return __classPrivateFieldGet(this, _Transaction_type, "f") == utils_1.EIP712_TX_TYPE ? __classPrivateFieldGet(this, _Transaction_type, "f") : super.type;
    }
    set type(value) {
        switch (value) {
            case utils_1.EIP712_TX_TYPE:
            case "eip-712":
                __classPrivateFieldSet(this, _Transaction_type, utils_1.EIP712_TX_TYPE, "f");
                break;
            default:
                super.type = value;
        }
    }
    static from(tx) {
        if (typeof tx === "string") {
            const payload = ethers_1.ethers.getBytes(tx);
            if (payload[0] !== utils_1.EIP712_TX_TYPE) {
                return Transaction.from(ethers_1.ethers.Transaction.from(tx));
            }
            else {
                return Transaction.from((0, utils_1.parseEip712)(payload));
            }
        }
        else {
            const result = new Transaction();
            if (tx.type === utils_1.EIP712_TX_TYPE) {
                result.type = utils_1.EIP712_TX_TYPE;
                result.customData = tx.customData;
                result.from = tx.from;
            }
            if (tx.type != null)
                result.type = tx.type;
            if (tx.to != null)
                result.to = tx.to;
            if (tx.nonce != null)
                result.nonce = tx.nonce;
            if (tx.gasLimit != null)
                result.gasLimit = tx.gasLimit;
            if (tx.gasPrice != null)
                result.gasPrice = tx.gasPrice;
            if (tx.maxPriorityFeePerGas != null)
                result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
            if (tx.maxFeePerGas != null)
                result.maxFeePerGas = tx.maxFeePerGas;
            if (tx.data != null)
                result.data = tx.data;
            if (tx.value != null)
                result.value = tx.value;
            if (tx.chainId != null)
                result.chainId = tx.chainId;
            if (tx.signature != null)
                result.signature = ethers_1.Signature.from(tx.signature);
            if (tx.accessList != null)
                result.accessList = tx.accessList;
            if (tx.from != null) {
                (0, ethers_1.assertArgument)(result.isSigned(), "unsigned transaction cannot define from", "tx", tx);
                (0, ethers_1.assertArgument)(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
            }
            if (tx.hash != null) {
                (0, ethers_1.assertArgument)(result.isSigned(), "unsigned transaction cannot define hash", "tx", tx);
                (0, ethers_1.assertArgument)(result.hash === tx.hash, "hash mismatch", "tx", tx);
            }
            return result;
        }
    }
    get serialized() {
        if (this.customData == null && __classPrivateFieldGet(this, _Transaction_type, "f") != utils_1.EIP712_TX_TYPE) {
            return super.serialized;
        }
        return (0, utils_1.serializeEip712)(this, this.signature);
    }
    get unsignedSerialized() {
        if (this.customData == null && this.type != utils_1.EIP712_TX_TYPE) {
            return super.unsignedSerialized;
        }
        return (0, utils_1.serializeEip712)(this);
    }
    toJSON() {
        const { customData } = this;
        return {
            ...super.toJSON(),
            type: __classPrivateFieldGet(this, _Transaction_type, "f") == null ? this.type : __classPrivateFieldGet(this, _Transaction_type, "f"),
            customData,
        };
    }
    get typeName() {
        return __classPrivateFieldGet(this, _Transaction_type, "f") === utils_1.EIP712_TX_TYPE ? "zksync" : super.typeName;
    }
    isSigned() {
        return __classPrivateFieldGet(this, _Transaction_type, "f") === utils_1.EIP712_TX_TYPE
            ? this.customData?.customSignature !== null
            : super.isSigned();
    }
    get hash() {
        if (__classPrivateFieldGet(this, _Transaction_type, "f") === utils_1.EIP712_TX_TYPE) {
            return this.customData?.customSignature !== null ? (0, utils_1.eip712TxHash)(this) : null;
        }
        else {
            return super.hash;
        }
    }
    get from() {
        return __classPrivateFieldGet(this, _Transaction_type, "f") === utils_1.EIP712_TX_TYPE ? __classPrivateFieldGet(this, _Transaction_from, "f") : super.from;
    }
    set from(value) {
        __classPrivateFieldSet(this, _Transaction_from, value, "f");
    }
}
exports.Transaction = Transaction;
_Transaction_type = new WeakMap(), _Transaction_from = new WeakMap();
var AccountAbstractionVersion;
(function (AccountAbstractionVersion) {
    AccountAbstractionVersion[AccountAbstractionVersion["None"] = 0] = "None";
    AccountAbstractionVersion[AccountAbstractionVersion["Version1"] = 1] = "Version1";
})(AccountAbstractionVersion || (exports.AccountAbstractionVersion = AccountAbstractionVersion = {}));
var AccountNonceOrdering;
(function (AccountNonceOrdering) {
    AccountNonceOrdering[AccountNonceOrdering["Sequential"] = 0] = "Sequential";
    AccountNonceOrdering[AccountNonceOrdering["Arbitrary"] = 1] = "Arbitrary";
})(AccountNonceOrdering || (exports.AccountNonceOrdering = AccountNonceOrdering = {}));
