import { InterfaceAbi, Interface, ethers, ContractRunner, BaseContract, ContractTransactionResponse, ContractDeployTransaction, ContractMethodArgs } from "ethers";
import { DeploymentType } from "./types";
export { Contract } from "ethers";
export declare class ContractFactory<A extends Array<any> = Array<any>, I = BaseContract> extends ethers.ContractFactory<A, I> {
    readonly deploymentType: DeploymentType;
    constructor(abi: Interface | InterfaceAbi, bytecode: ethers.BytesLike, runner?: ContractRunner, deploymentType?: DeploymentType);
    private encodeCalldata;
    protected checkOverrides(overrides: ethers.Overrides): void;
    getDeployTransaction(...args: ContractMethodArgs<A>): Promise<ContractDeployTransaction>;
    /**
     * Deploys a new contract or account instance on the Ethereum blockchain.
     * There is no need to wait for deployment with {@link BaseContract#waitForDeployment|BaseContract.waitForDeployment}
     * because **deploy** already waits for deployment to finish.
     *
     * @async
     * @param {...ContractMethodArgs} args - Constructor arguments for the contract followed by optional
     * {@link ethers.Overrides|overrides}. When deploying with CREATE2 opcode slat must be present in overrides.
     *
     *
     * @example
     * // Deploy with constructor arguments only using CREATE opcode
     * const deployedContract = await contractFactory.deploy(arg1, arg2, ...);
     *
     * // Deploy with constructor arguments, and factory dependencies using CREATE opcode
     * const deployedContractWithSaltAndDeps = await contractFactory.deploy(arg1, arg2, ..., {
     *   customData: {
     *     factoryDeps: ['0x...']
     *   }
     * });
     *
     * // Deploy with constructor arguments and custom salt using CREATE2 opcode
     * const deployedContractWithSalt = await contractFactory.deploy(arg1, arg2, ..., {
     *   customData: {
     *     salt: '0x...'
     *   }
     * });
     *
     * // Deploy with constructor arguments, custom salt, and factory dependencies using CREATE2 opcode
     * const deployedContractWithSaltAndDeps = await contractFactory.deploy(arg1, arg2, ..., {
     *   customData: {
     *     salt: '0x...',
     *     factoryDeps: ['0x...']
     *   }
     * });
     */
    deploy(...args: ContractMethodArgs<A>): Promise<BaseContract & {
        deploymentTransaction(): ContractTransactionResponse;
    } & Omit<I, keyof BaseContract>>;
}
