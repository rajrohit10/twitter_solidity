"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1VoidSigner = exports.L2VoidSigner = exports.L1Signer = exports.Signer = exports.EIP712Signer = exports.eip712Types = void 0;
const ethers_1 = require("ethers");
const utils_1 = require("./utils");
const adapters_1 = require("./adapters");
exports.eip712Types = {
    Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" },
    ],
};
class EIP712Signer {
    constructor(ethSigner, chainId) {
        this.ethSigner = ethSigner;
        this.eip712Domain = Promise.resolve(chainId).then((chainId) => ({
            name: "zkSync",
            version: "2",
            chainId,
        }));
    }
    static getSignInput(transaction) {
        const maxFeePerGas = transaction.maxFeePerGas || transaction.gasPrice;
        const maxPriorityFeePerGas = transaction.maxPriorityFeePerGas || maxFeePerGas;
        const gasPerPubdataByteLimit = transaction.customData?.gasPerPubdata || utils_1.DEFAULT_GAS_PER_PUBDATA_LIMIT;
        return {
            txType: transaction.type,
            from: transaction.from,
            to: transaction.to,
            gasLimit: transaction.gasLimit,
            gasPerPubdataByteLimit: gasPerPubdataByteLimit,
            maxFeePerGas,
            maxPriorityFeePerGas,
            paymaster: transaction.customData?.paymasterParams?.paymaster || ethers_1.ethers.ZeroAddress,
            nonce: transaction.nonce,
            value: transaction.value,
            data: transaction.data,
            factoryDeps: transaction.customData?.factoryDeps?.map((dep) => (0, utils_1.hashBytecode)(dep)) || [],
            paymasterInput: transaction.customData?.paymasterParams?.paymasterInput || "0x",
        };
    }
    async sign(transaction) {
        return await this.ethSigner.signTypedData(await this.eip712Domain, exports.eip712Types, EIP712Signer.getSignInput(transaction));
    }
    static getSignedDigest(transaction) {
        if (!transaction.chainId) {
            throw Error("Transaction chainId isn't set");
        }
        const domain = {
            name: "zkSync",
            version: "2",
            chainId: transaction.chainId,
        };
        return ethers_1.ethers.TypedDataEncoder.hash(domain, exports.eip712Types, EIP712Signer.getSignInput(transaction));
    }
}
exports.EIP712Signer = EIP712Signer;
// This class is to be used on the frontend, with metamask injection.
// It only contains L2 operations. For L1 operations, see L1Signer.
// Sample usage:
// const provider = new BrowserProvider(window.ethereum);
// const signer = provider.getSigner();
// const tx = await signer.sendTransaction({ ... });
class Signer extends (0, adapters_1.AdapterL2)(ethers_1.ethers.JsonRpcSigner) {
    _signerL2() {
        return this;
    }
    _providerL2() {
        return this.provider;
    }
    static from(signer, chainId) {
        const newSigner = Object.setPrototypeOf(signer, Signer.prototype);
        newSigner.eip712 = new EIP712Signer(newSigner, chainId);
        return newSigner;
    }
    async sendTransaction(transaction) {
        if (transaction.customData == null && transaction.type == null) {
            // use legacy txs by default
            transaction.type = 0;
        }
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
            return (await super.sendTransaction(transaction));
        }
        else {
            const address = await this.getAddress();
            const from = await ethers_1.ethers.resolveAddress(transaction.from);
            if (from.toLowerCase() != address.toLowerCase()) {
                throw new Error("Transaction `from` address mismatch");
            }
            const tx = {
                type: transaction.type ?? utils_1.EIP712_TX_TYPE,
                value: transaction.value ?? 0,
                data: transaction.data ?? "0x",
                nonce: transaction.nonce ?? (await this.getNonce()),
                gasPrice: transaction.gasPrice ?? (await this.provider.getGasPrice()),
                gasLimit: transaction.gasLimit ?? (await this.provider.estimateGas(transaction)),
                chainId: transaction.chainId ?? (await this.provider.getNetwork()).chainId,
                to: await ethers_1.ethers.resolveAddress(transaction.to),
                customData: this._fillCustomData(transaction.customData ?? {}),
                from,
            };
            tx.customData ?? (tx.customData = {});
            tx.customData.customSignature = await this.eip712.sign(tx);
            const txBytes = (0, utils_1.serializeEip712)(tx);
            return await this.provider.broadcastTransaction(txBytes);
        }
    }
}
exports.Signer = Signer;
// This class is to be used on the frontend with metamask injection.
// It only contains L1 operations. For L2 operations, see Signer.
// Sample usage:
// const ethProvider = new ethers.BrowserProvider(window.ethereum);
// const provider = new Provider('<rpc_url>');
// const signer = L1Signer.from(ethProvider.getSigner(), provider);
// const tx = await signer.deposit({ ... });
class L1Signer extends (0, adapters_1.AdapterL1)(ethers_1.ethers.JsonRpcSigner) {
    _providerL2() {
        return this.providerL2;
    }
    _providerL1() {
        return this.provider;
    }
    _signerL1() {
        return this;
    }
    static from(signer, zksyncProvider) {
        const newSigner = Object.setPrototypeOf(signer, L1Signer.prototype);
        newSigner.providerL2 = zksyncProvider;
        return newSigner;
    }
    connectToL2(provider) {
        this.providerL2 = provider;
        return this;
    }
}
exports.L1Signer = L1Signer;
class L2VoidSigner extends (0, adapters_1.AdapterL2)(ethers_1.ethers.VoidSigner) {
    _signerL2() {
        return this;
    }
    _providerL2() {
        return this.provider;
    }
    static from(signer, chainId) {
        const newSigner = Object.setPrototypeOf(signer, L2VoidSigner.prototype);
        newSigner.eip712 = new EIP712Signer(newSigner, chainId);
        return newSigner;
    }
    async sendTransaction(transaction) {
        if (transaction.customData == null && transaction.type == null) {
            // use legacy txs by default
            transaction.type = 0;
        }
        if (transaction.customData == null && transaction.type != utils_1.EIP712_TX_TYPE) {
            return (await super.sendTransaction(transaction));
        }
        else {
            const address = await this.getAddress();
            const from = await ethers_1.ethers.resolveAddress(transaction.from);
            if (from.toLowerCase() != address.toLowerCase()) {
                throw new Error("Transaction `from` address mismatch");
            }
            const tx = {
                type: transaction.type ?? utils_1.EIP712_TX_TYPE,
                value: transaction.value ?? 0,
                data: transaction.data ?? "0x",
                nonce: transaction.nonce ?? (await this.getNonce()),
                gasPrice: transaction.gasPrice ?? (await this.provider.getGasPrice()),
                gasLimit: transaction.gasLimit ?? (await this.provider.estimateGas(transaction)),
                chainId: transaction.chainId ?? (await this.provider.getNetwork()).chainId,
                to: await ethers_1.ethers.resolveAddress(transaction.to),
                customData: this._fillCustomData(transaction.customData ?? {}),
                from,
            };
            tx.customData ?? (tx.customData = {});
            tx.customData.customSignature = await this.eip712.sign(tx);
            const txBytes = (0, utils_1.serializeEip712)(tx);
            return await this.provider.broadcastTransaction(txBytes);
        }
    }
}
exports.L2VoidSigner = L2VoidSigner;
// This class is to be used on the frontend with metamask injection.
// It only contains L1 operations. For L2 operations, see Signer.
// Sample usage:
// const ethProvider = new ethers.BrowserProvider(window.ethereum);
// const provider = new Provider('<rpc_url>');
// const signer = L1Signer.from(provider.getSigner(), zksyncProvider);
// const tx = await signer.deposit({ ... });
class L1VoidSigner extends (0, adapters_1.AdapterL1)(ethers_1.ethers.VoidSigner) {
    _providerL2() {
        return this.providerL2;
    }
    _providerL1() {
        // @ts-ignore
        return this.provider;
    }
    _signerL1() {
        return this;
    }
    static from(signer, zksyncProvider) {
        const newSigner = Object.setPrototypeOf(signer, L1VoidSigner.prototype);
        newSigner.providerL2 = zksyncProvider;
        return newSigner;
    }
    connectToL2(provider) {
        this.providerL2 = provider;
        return this;
    }
}
exports.L1VoidSigner = L1VoidSigner;
