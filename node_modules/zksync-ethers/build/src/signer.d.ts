import { ethers } from "ethers";
import { Provider } from "./provider";
import { Signature, TransactionRequest, TransactionResponse } from "./types";
export declare const eip712Types: {
    Transaction: {
        name: string;
        type: string;
    }[];
};
export declare class EIP712Signer {
    private ethSigner;
    private eip712Domain;
    constructor(ethSigner: ethers.Signer, chainId: number | Promise<number>);
    static getSignInput(transaction: TransactionRequest): {
        txType: number | null | undefined;
        from: ethers.AddressLike | null | undefined;
        to: ethers.AddressLike | null | undefined;
        gasLimit: ethers.BigNumberish | null | undefined;
        gasPerPubdataByteLimit: ethers.BigNumberish;
        maxFeePerGas: ethers.BigNumberish | null | undefined;
        maxPriorityFeePerGas: ethers.BigNumberish | null | undefined;
        paymaster: string;
        nonce: number | null | undefined;
        value: ethers.BigNumberish | null | undefined;
        data: string | null | undefined;
        factoryDeps: Uint8Array[];
        paymasterInput: ethers.BytesLike;
    };
    sign(transaction: TransactionRequest): Promise<Signature>;
    static getSignedDigest(transaction: TransactionRequest): ethers.BytesLike;
}
declare const Signer_base: {
    new (...args: any[]): {
        _providerL2(): Provider;
        _signerL2(): ethers.Signer;
        getBalance(token?: string | undefined, blockTag?: ethers.BlockTag): Promise<bigint>;
        getAllBalances(): Promise<import("./types").BalancesMap>;
        getDeploymentNonce(): Promise<bigint>;
        getL2BridgeContracts(): Promise<{
            erc20: import("../typechain").IL2Bridge;
            weth: import("../typechain").IL2Bridge;
        }>;
        _fillCustomData(data: import("./types").Eip712Meta): import("./types").Eip712Meta;
        withdraw(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<TransactionResponse>;
        transfer(transaction: {
            to: string;
            amount: ethers.BigNumberish;
            token?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<TransactionResponse>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & typeof ethers.JsonRpcSigner;
export declare class Signer extends Signer_base {
    provider: Provider;
    eip712: EIP712Signer;
    _signerL2(): this;
    _providerL2(): Provider;
    static from(signer: ethers.JsonRpcSigner & {
        provider: Provider;
    }, chainId: number): Signer;
    sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;
}
declare const L1Signer_base: {
    new (...args: any[]): {
        _providerL2(): Provider;
        _providerL1(): ethers.Provider;
        _signerL1(): ethers.Signer;
        getMainContract(): Promise<import("../typechain").IZkSync>;
        getL1BridgeContracts(): Promise<{
            erc20: import("../typechain").IL1Bridge;
            weth: import("../typechain").IL1Bridge;
        }>;
        getBalanceL1(token?: string | undefined, blockTag?: ethers.BlockTag | undefined): Promise<bigint>;
        getAllowanceL1(token: string, bridgeAddress?: string | undefined, blockTag?: ethers.BlockTag | undefined): Promise<bigint>;
        l2TokenAddress(token: string): Promise<string>;
        approveERC20(token: string, amount: ethers.BigNumberish, overrides?: (ethers.Overrides & {
            bridgeAddress?: string | undefined;
        }) | undefined): Promise<ethers.TransactionResponse>;
        getBaseCost(params: {
            gasLimit: ethers.BigNumberish;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            gasPrice?: ethers.BigNumberish | undefined;
        }): Promise<bigint>;
        deposit(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            bridgeAddress?: string | undefined;
            approveERC20?: boolean | undefined;
            l2GasLimit?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
            approveOverrides?: ethers.Overrides | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
        }): Promise<import("./types").PriorityOpResponse>;
        estimateGasDeposit(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            bridgeAddress?: string | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
            l2GasLimit?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getDepositTx(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            bridgeAddress?: string | undefined;
            l2GasLimit?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<any>;
        getFullRequiredDepositFee(transaction: {
            token: string;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<import("./types").FullDepositFee>;
        _getWithdrawalLog(withdrawalHash: ethers.BytesLike, index?: number): Promise<{
            log: import("./types").Log;
            l1BatchTxId: number | null;
        }>;
        _getWithdrawalL2ToL1Log(withdrawalHash: ethers.BytesLike, index?: number): Promise<{
            l2ToL1LogIndex: number;
            l2ToL1Log: import("./types").L2ToL1Log;
        }>;
        finalizeWithdrawalParams(withdrawalHash: ethers.BytesLike, index?: number): Promise<{
            l1BatchNumber: number | null;
            l2MessageIndex: number;
            l2TxNumberInBlock: number | null;
            message: any;
            sender: string;
            proof: string[];
        }>;
        finalizeWithdrawal(withdrawalHash: ethers.BytesLike, index?: number, overrides?: ethers.Overrides | undefined): Promise<ethers.ContractTransactionResponse>;
        isWithdrawalFinalized(withdrawalHash: ethers.BytesLike, index?: number): Promise<boolean>;
        claimFailedDeposit(depositHash: ethers.BytesLike, overrides?: ethers.Overrides | undefined): Promise<ethers.ContractTransactionResponse>;
        requestExecute(transaction: {
            contractAddress: string;
            calldata: string;
            l2GasLimit: ethers.BigNumberish;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<import("./types").PriorityOpResponse>;
        estimateGasRequestExecute(transaction: {
            contractAddress: string;
            calldata: string;
            l2GasLimit?: ethers.BigNumberish | undefined;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getRequestExecuteTx(transaction: {
            contractAddress: string;
            calldata: string;
            l2GasLimit?: ethers.BigNumberish | undefined;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<ethers.TransactionRequest>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & typeof ethers.JsonRpcSigner;
export declare class L1Signer extends L1Signer_base {
    providerL2: Provider;
    _providerL2(): Provider;
    _providerL1(): ethers.JsonRpcApiProvider;
    _signerL1(): this;
    static from(signer: ethers.JsonRpcSigner, zksyncProvider: Provider): L1Signer;
    connectToL2(provider: Provider): this;
}
declare const L2VoidSigner_base: {
    new (...args: any[]): {
        _providerL2(): Provider;
        _signerL2(): ethers.Signer;
        getBalance(token?: string | undefined, blockTag?: ethers.BlockTag): Promise<bigint>;
        getAllBalances(): Promise<import("./types").BalancesMap>;
        getDeploymentNonce(): Promise<bigint>;
        getL2BridgeContracts(): Promise<{
            erc20: import("../typechain").IL2Bridge;
            weth: import("../typechain").IL2Bridge;
        }>;
        _fillCustomData(data: import("./types").Eip712Meta): import("./types").Eip712Meta;
        withdraw(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<TransactionResponse>;
        transfer(transaction: {
            to: string;
            amount: ethers.BigNumberish;
            token?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<TransactionResponse>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & typeof ethers.VoidSigner;
export declare class L2VoidSigner extends L2VoidSigner_base {
    provider: Provider;
    eip712: EIP712Signer;
    _signerL2(): this;
    _providerL2(): Provider;
    static from(signer: ethers.VoidSigner & {
        provider: Provider;
    }, chainId: number): L2VoidSigner;
    sendTransaction(transaction: TransactionRequest): Promise<TransactionResponse>;
}
declare const L1VoidSigner_base: {
    new (...args: any[]): {
        _providerL2(): Provider;
        _providerL1(): ethers.Provider;
        _signerL1(): ethers.Signer;
        getMainContract(): Promise<import("../typechain").IZkSync>;
        getL1BridgeContracts(): Promise<{
            erc20: import("../typechain").IL1Bridge;
            weth: import("../typechain").IL1Bridge;
        }>;
        getBalanceL1(token?: string | undefined, blockTag?: ethers.BlockTag | undefined): Promise<bigint>;
        getAllowanceL1(token: string, bridgeAddress?: string | undefined, blockTag?: ethers.BlockTag | undefined): Promise<bigint>;
        l2TokenAddress(token: string): Promise<string>;
        approveERC20(token: string, amount: ethers.BigNumberish, overrides?: (ethers.Overrides & {
            bridgeAddress?: string | undefined;
        }) | undefined): Promise<ethers.TransactionResponse>;
        getBaseCost(params: {
            gasLimit: ethers.BigNumberish;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            gasPrice?: ethers.BigNumberish | undefined;
        }): Promise<bigint>;
        deposit(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            bridgeAddress?: string | undefined;
            approveERC20?: boolean | undefined;
            l2GasLimit?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
            approveOverrides?: ethers.Overrides | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
        }): Promise<import("./types").PriorityOpResponse>;
        estimateGasDeposit(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            bridgeAddress?: string | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
            l2GasLimit?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getDepositTx(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            to?: string | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            bridgeAddress?: string | undefined;
            l2GasLimit?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<any>;
        getFullRequiredDepositFee(transaction: {
            token: string;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            customBridgeData?: ethers.BytesLike | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<import("./types").FullDepositFee>;
        _getWithdrawalLog(withdrawalHash: ethers.BytesLike, index?: number): Promise<{
            log: import("./types").Log;
            l1BatchTxId: number | null;
        }>;
        _getWithdrawalL2ToL1Log(withdrawalHash: ethers.BytesLike, index?: number): Promise<{
            l2ToL1LogIndex: number;
            l2ToL1Log: import("./types").L2ToL1Log;
        }>;
        finalizeWithdrawalParams(withdrawalHash: ethers.BytesLike, index?: number): Promise<{
            l1BatchNumber: number | null;
            l2MessageIndex: number;
            l2TxNumberInBlock: number | null;
            message: any;
            sender: string;
            proof: string[];
        }>;
        finalizeWithdrawal(withdrawalHash: ethers.BytesLike, index?: number, overrides?: ethers.Overrides | undefined): Promise<ethers.ContractTransactionResponse>;
        isWithdrawalFinalized(withdrawalHash: ethers.BytesLike, index?: number): Promise<boolean>;
        claimFailedDeposit(depositHash: ethers.BytesLike, overrides?: ethers.Overrides | undefined): Promise<ethers.ContractTransactionResponse>;
        requestExecute(transaction: {
            contractAddress: string;
            calldata: string;
            l2GasLimit: ethers.BigNumberish;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<import("./types").PriorityOpResponse>;
        estimateGasRequestExecute(transaction: {
            contractAddress: string;
            calldata: string;
            l2GasLimit?: ethers.BigNumberish | undefined;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getRequestExecuteTx(transaction: {
            contractAddress: string;
            calldata: string;
            l2GasLimit?: ethers.BigNumberish | undefined;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            operatorTip?: ethers.BigNumberish | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            refundRecipient?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<ethers.TransactionRequest>;
        sendTransaction(tx: ethers.TransactionRequest): Promise<ethers.TransactionResponse>;
        getAddress(): Promise<string>;
    };
} & typeof ethers.VoidSigner;
export declare class L1VoidSigner extends L1VoidSigner_base {
    providerL2: Provider;
    _providerL2(): Provider;
    _providerL1(): ethers.Provider;
    _signerL1(): this;
    static from(signer: ethers.VoidSigner, zksyncProvider: Provider): L1VoidSigner;
    connectToL2(provider: Provider): this;
}
export {};
