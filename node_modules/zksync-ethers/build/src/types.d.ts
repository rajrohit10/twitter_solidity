import { BigNumberish, BytesLike, ethers, TransactionRequest as EthersTransactionRequest } from "ethers";
export type Address = string;
export type Signature = string;
export declare enum Network {
    Mainnet = 1,
    Ropsten = 3,
    Rinkeby = 4,
    Goerli = 5,
    Sepolia = 6,
    Localhost = 9
}
export declare enum PriorityQueueType {
    Deque = 0,
    HeapBuffer = 1,
    Heap = 2
}
export declare enum PriorityOpTree {
    Full = 0,
    Rollup = 1
}
export declare enum TransactionStatus {
    NotFound = "not-found",
    Processing = "processing",
    Committed = "committed",
    Finalized = "finalized"
}
export type PaymasterParams = {
    paymaster: Address;
    paymasterInput: BytesLike;
};
export type Eip712Meta = {
    gasPerPubdata?: BigNumberish;
    factoryDeps?: BytesLike[];
    customSignature?: BytesLike;
    paymasterParams?: PaymasterParams;
};
export type BlockTag = BigNumberish | string | "committed" | "finalized" | "latest" | "earliest" | "pending";
export type DeploymentType = "create" | "createAccount" | "create2" | "create2Account";
export interface Token {
    l1Address: Address;
    l2Address: Address;
    name: string;
    symbol: string;
    decimals: number;
}
export interface Fee {
    readonly gasLimit: bigint;
    readonly gasPerPubdataLimit: bigint;
    readonly maxPriorityFeePerGas: bigint;
    readonly maxFeePerGas: bigint;
}
export interface MessageProof {
    id: number;
    proof: string[];
    root: string;
}
export declare class TransactionResponse extends ethers.TransactionResponse {
    readonly l1BatchNumber: null | number;
    readonly l1BatchTxIndex: null | number;
    constructor(params: any, provider: ethers.Provider);
    wait(confirmations?: number): Promise<TransactionReceipt>;
    getTransaction(): Promise<TransactionResponse>;
    replaceableTransaction(startBlock: number): TransactionResponse;
    getBlock(): Promise<Block>;
    waitFinalize(): Promise<TransactionReceipt>;
    toJSON(): any;
}
export declare class TransactionReceipt extends ethers.TransactionReceipt {
    readonly l1BatchNumber: null | number;
    readonly l1BatchTxIndex: null | number;
    readonly l2ToL1Logs: L2ToL1Log[];
    readonly _logs: ReadonlyArray<Log>;
    constructor(params: any, provider: ethers.Provider);
    get logs(): ReadonlyArray<Log>;
    getBlock(): Promise<Block>;
    getTransaction(): Promise<TransactionResponse>;
    toJSON(): any;
}
export declare class Block extends ethers.Block {
    readonly l1BatchNumber: null | number;
    readonly l1BatchTimestamp: null | number;
    constructor(params: any, provider: ethers.Provider);
    toJSON(): any;
    get prefetchedTransactions(): TransactionResponse[];
    getTransaction(indexOrHash: number | string): Promise<TransactionResponse>;
}
export interface LogParams extends ethers.LogParams {
    readonly l1BatchNumber: null | number;
}
export declare class Log extends ethers.Log {
    readonly l1BatchNumber: null | number;
    constructor(params: LogParams, provider: ethers.Provider);
    toJSON(): any;
    getBlock(): Promise<Block>;
    getTransaction(): Promise<TransactionResponse>;
    getTransactionReceipt(): Promise<TransactionReceipt>;
}
export interface TransactionLike extends ethers.TransactionLike {
    customData?: null | Eip712Meta;
}
export declare class Transaction extends ethers.Transaction {
    #private;
    customData?: null | Eip712Meta;
    get type(): number | null;
    set type(value: number | string | null);
    static from(tx: string | TransactionLike): Transaction;
    get serialized(): string;
    get unsignedSerialized(): string;
    toJSON(): any;
    get typeName(): string | null;
    isSigned(): this is Transaction & {
        type: number;
        typeName: string;
        from: string;
        signature: Signature;
    };
    get hash(): string | null;
    get from(): string | null;
    set from(value: string | null);
}
export interface L2ToL1Log {
    blockNumber: number;
    blockHash: string;
    l1BatchNumber: number;
    transactionIndex: number;
    shardId: number;
    isService: boolean;
    sender: string;
    key: string;
    value: string;
    transactionHash: string;
    logIndex: number;
}
export interface TransactionRequest extends EthersTransactionRequest {
    customData?: null | Eip712Meta;
}
export interface PriorityOpResponse extends TransactionResponse {
    waitL1Commit(confirmation?: number): Promise<ethers.TransactionReceipt>;
}
export type BalancesMap = {
    [key: string]: bigint;
};
export interface DeploymentInfo {
    sender: Address;
    bytecodeHash: string;
    deployedAddress: Address;
}
export interface ApprovalBasedPaymasterInput {
    type: "ApprovalBased";
    token: Address;
    minimalAllowance: BigNumberish;
    innerInput: BytesLike;
}
export interface GeneralPaymasterInput {
    type: "General";
    innerInput: BytesLike;
}
export interface EthereumSignature {
    v: number;
    r: BytesLike;
    s: BytesLike;
}
export type PaymasterInput = ApprovalBasedPaymasterInput | GeneralPaymasterInput;
export declare enum AccountAbstractionVersion {
    None = 0,
    Version1 = 1
}
export declare enum AccountNonceOrdering {
    Sequential = 0,
    Arbitrary = 1
}
export interface ContractAccountInfo {
    supportedAAVersion: AccountAbstractionVersion;
    nonceOrdering: AccountNonceOrdering;
}
export interface BatchDetails {
    number: number;
    timestamp: number;
    l1TxCount: number;
    l2TxCount: number;
    rootHash?: string;
    status: string;
    commitTxHash?: string;
    committedAt?: Date;
    proveTxHash?: string;
    provenAt?: Date;
    executeTxHash?: string;
    executedAt?: Date;
    l1GasPrice: number;
    l2FairGasPrice: number;
}
export interface BlockDetails {
    number: number;
    timestamp: number;
    l1BatchNumber: number;
    l1TxCount: number;
    l2TxCount: number;
    rootHash?: string;
    status: string;
    commitTxHash?: string;
    committedAt?: Date;
    proveTxHash?: string;
    provenAt?: Date;
    executeTxHash?: string;
    executedAt?: Date;
}
export interface TransactionDetails {
    isL1Originated: boolean;
    status: string;
    fee: BigNumberish;
    initiatorAddress: Address;
    receivedAt: Date;
    ethCommitTxHash?: string;
    ethProveTxHash?: string;
    ethExecuteTxHash?: string;
}
export interface FullDepositFee {
    maxFeePerGas?: BigInt;
    maxPriorityFeePerGas?: BigInt;
    gasPrice?: BigInt;
    baseCost: BigInt;
    l1GasLimit: BigInt;
    l2GasLimit: BigInt;
}
export interface RawBlockTransaction {
    common_data: {
        L2: {
            nonce: number;
            fee: {
                gas_limit: BigInt;
                max_fee_per_gas: BigInt;
                max_priority_fee_per_gas: BigInt;
                gas_per_pubdata_limit: BigInt;
            };
            initiatorAddress: Address;
            signature: Uint8Array;
            transactionType: string;
            input: {
                hash: string;
                data: Uint8Array;
            };
            paymasterParams: {
                paymaster: Address;
                paymasterInput: Uint8Array;
            };
        };
    };
    execute: {
        calldata: string;
        contractAddress: Address;
        factoryDeps: BytesLike[];
        value: BigInt;
    };
    received_timestamp_ms: number;
    raw_bytes: string;
}
