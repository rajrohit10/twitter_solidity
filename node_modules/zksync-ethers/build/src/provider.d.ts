import { ethers, BigNumberish, BytesLike, BlockTag, Filter, FilterByBlockHash, TransactionRequest as EthersTransactionRequest, JsonRpcTransactionRequest, Networkish, Eip1193Provider, JsonRpcError, JsonRpcResult, JsonRpcPayload } from "ethers";
import { Address, TransactionResponse, TransactionRequest, TransactionStatus, Token, PriorityOpResponse, BalancesMap, MessageProof, TransactionReceipt, Block, Log, TransactionDetails, BlockDetails, ContractAccountInfo, Network as ZkSyncNetwork, BatchDetails, Fee, RawBlockTransaction } from "./types";
import { Signer } from "./signer";
type Constructor<T = {}> = new (...args: any[]) => T;
export declare function JsonRpcApiProvider<TBase extends Constructor<ethers.JsonRpcApiProvider>>(ProviderType: TBase): {
    new (...args: any[]): {
        _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>>;
        contractAddresses(): {
            mainContract?: Address;
            erc20BridgeL1?: Address;
            erc20BridgeL2?: Address;
            wethBridgeL1?: Address;
            wethBridgeL2?: Address;
        };
        _getBlockTag(blockTag?: BlockTag): string | Promise<string>;
        _wrapLog(value: any, network: ethers.Network): Log;
        _wrapBlock(value: any, network: ethers.Network): Block;
        _wrapTransactionResponse(value: any, network: ethers.Network): TransactionResponse;
        _wrapTransactionReceipt(value: any, network: ethers.Network): TransactionReceipt;
        getTransactionReceipt(txHash: string): Promise<TransactionReceipt>;
        getTransaction(txHash: string): Promise<TransactionResponse>;
        getBlock(blockHashOrBlockTag: BlockTag, includeTxs?: boolean): Promise<Block>;
        getLogs(filter: Filter | FilterByBlockHash): Promise<Log[]>;
        getBalance(address: Address, blockTag?: BlockTag, tokenAddress?: Address): Promise<bigint>;
        l2TokenAddress(token: Address): Promise<string>;
        l1TokenAddress(token: Address): Promise<string>;
        estimateGasL1(transaction: TransactionRequest): Promise<bigint>;
        estimateFee(transaction: TransactionRequest): Promise<Fee>;
        getGasPrice(): Promise<bigint>;
        getLogProof(txHash: BytesLike, index?: number): Promise<MessageProof | null>;
        getL1BatchBlockRange(l1BatchNumber: number): Promise<[number, number] | null>;
        getMainContractAddress(): Promise<Address>;
        getTestnetPaymasterAddress(): Promise<Address | null>;
        getDefaultBridgeAddresses(): Promise<{
            erc20L1: string | undefined;
            erc20L2: string | undefined;
            wethL1: string | undefined;
            wethL2: string | undefined;
        }>;
        getConfirmedTokens(start?: number, limit?: number): Promise<Token[]>;
        getAllAccountBalances(address: Address): Promise<BalancesMap>;
        l1ChainId(): Promise<number>;
        getL1BatchNumber(): Promise<number>;
        getL1BatchDetails(number: number): Promise<BatchDetails>;
        getBlockDetails(number: number): Promise<BlockDetails>;
        getTransactionDetails(txHash: BytesLike): Promise<TransactionDetails>;
        getBytecodeByHash(bytecodeHash: BytesLike): Promise<Uint8Array>;
        getRawBlockTransactions(number: number): Promise<RawBlockTransaction[]>;
        getWithdrawTx(transaction: {
            token: Address;
            amount: BigNumberish;
            from?: Address;
            to?: Address;
            bridgeAddress?: Address;
            overrides?: ethers.Overrides;
        }): Promise<EthersTransactionRequest>;
        estimateGasWithdraw(transaction: {
            token: Address;
            amount: BigNumberish;
            from?: Address;
            to?: Address;
            bridgeAddress?: Address;
            overrides?: ethers.Overrides;
        }): Promise<bigint>;
        getTransferTx(transaction: {
            to: Address;
            amount: BigNumberish;
            from?: Address;
            token?: Address;
            overrides?: ethers.Overrides;
        }): Promise<EthersTransactionRequest>;
        estimateGasTransfer(transaction: {
            to: Address;
            amount: BigNumberish;
            from?: Address;
            token?: Address;
            overrides?: ethers.Overrides;
        }): Promise<bigint>;
        newFilter(filter: FilterByBlockHash | Filter): Promise<bigint>;
        newBlockFilter(): Promise<bigint>;
        newPendingTransactionsFilter(): Promise<bigint>;
        getFilterChanges(idx: bigint): Promise<Array<Log | string>>;
        getTransactionStatus(txHash: string): Promise<TransactionStatus>;
        broadcastTransaction(signedTx: string): Promise<TransactionResponse>;
        getL2TransactionFromPriorityOp(l1TxResponse: ethers.TransactionResponse): Promise<TransactionResponse>;
        getPriorityOpResponse(l1TxResponse: ethers.TransactionResponse): Promise<PriorityOpResponse>;
        getContractAccountInfo(address: Address): Promise<ContractAccountInfo>;
        estimateL1ToL2Execute(transaction: {
            contractAddress: Address;
            calldata: string;
            caller?: Address;
            l2Value?: BigNumberish;
            factoryDeps?: ethers.BytesLike[];
            gasPerPubdataByte?: BigNumberish;
            overrides?: ethers.Overrides;
        }): Promise<bigint>;
        getRpcTransaction(tx: TransactionRequest): JsonRpcTransactionRequest;
        "__#17@#private": any;
        _getOption<K extends keyof ethers.JsonRpcApiProviderOptions>(key: K): ethers.JsonRpcApiProviderOptions[K];
        readonly _network: ethers.Network;
        _perform(req: ethers.PerformActionRequest): Promise<any>;
        _detectNetwork(): Promise<ethers.Network>;
        _start(): void;
        _waitUntilReady(): Promise<void>;
        _getSubscriber(sub: ethers.Subscription): ethers.Subscriber;
        readonly ready: boolean;
        getRpcRequest(req: ethers.PerformActionRequest): {
            method: string;
            args: any[];
        } | null;
        getRpcError(payload: ethers.JsonRpcPayload, _error: ethers.JsonRpcError): Error;
        send(method: string, params: any[] | Record<string, any>): Promise<any>;
        getSigner(address?: string | number | undefined): Promise<ethers.JsonRpcSigner>;
        listAccounts(): Promise<ethers.JsonRpcSigner[]>;
        destroy(): void;
        "__#14@#private": any;
        readonly pollingInterval: number;
        readonly provider: any;
        readonly plugins: ethers.AbstractProviderPlugin[];
        attachPlugin(plugin: ethers.AbstractProviderPlugin): any;
        getPlugin<T extends ethers.AbstractProviderPlugin = ethers.AbstractProviderPlugin>(name: string): T | null;
        disableCcipRead: boolean;
        ccipReadFetch(tx: ethers.PerformActionTransaction, calldata: string, urls: string[]): Promise<string | null>;
        getBlockNumber(): Promise<number>;
        _getAddress(address: ethers.AddressLike): string | Promise<string>;
        _getFilter(filter: ethers.Filter | ethers.FilterByBlockHash): ethers.PerformActionFilter | Promise<ethers.PerformActionFilter>;
        _getTransactionRequest(_request: ethers.TransactionRequest): ethers.PerformActionTransaction | Promise<ethers.PerformActionTransaction>;
        getNetwork(): Promise<ethers.Network>;
        getFeeData(): Promise<ethers.FeeData>;
        estimateGas(_tx: ethers.TransactionRequest): Promise<bigint>;
        call(_tx: ethers.TransactionRequest): Promise<string>;
        getTransactionCount(address: ethers.AddressLike, blockTag?: ethers.BlockTag | undefined): Promise<number>;
        getCode(address: ethers.AddressLike, blockTag?: ethers.BlockTag | undefined): Promise<string>;
        getStorage(address: ethers.AddressLike, _position: ethers.BigNumberish, blockTag?: ethers.BlockTag | undefined): Promise<string>;
        getTransactionResult(hash: string): Promise<string | null>;
        _getProvider(chainId: number): ethers.AbstractProvider;
        getResolver(name: string): Promise<ethers.EnsResolver | null>;
        getAvatar(name: string): Promise<string | null>;
        resolveName(name: string): Promise<string | null>;
        lookupAddress(address: string): Promise<string | null>;
        waitForTransaction(hash: string, _confirms?: number | null | undefined, timeout?: number | null | undefined): Promise<ethers.TransactionReceipt | null>;
        waitForBlock(blockTag?: ethers.BlockTag | undefined): Promise<ethers.Block>;
        _clearTimeout(timerId: number): void;
        _setTimeout(_func: () => void, timeout?: number | undefined): number;
        _forEachSubscriber(func: (s: ethers.Subscriber) => void): void;
        _recoverSubscriber(oldSub: ethers.Subscriber, newSub: ethers.Subscriber): void;
        on(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        once(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        emit(event: ethers.ProviderEvent, ...args: any[]): Promise<boolean>;
        listenerCount(event?: ethers.ProviderEvent | undefined): Promise<number>;
        listeners(event?: ethers.ProviderEvent | undefined): Promise<ethers.Listener[]>;
        off(event: ethers.ProviderEvent, listener?: ethers.Listener | undefined): Promise<any>;
        removeAllListeners(event?: ethers.ProviderEvent | undefined): Promise<any>;
        addListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        removeListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        readonly destroyed: boolean;
        paused: boolean;
        pause(dropWhilePaused?: boolean | undefined): void;
        resume(): void;
    };
} & TBase;
declare const Provider_base: {
    new (...args: any[]): {
        _send(payload: ethers.JsonRpcPayload | ethers.JsonRpcPayload[]): Promise<(ethers.JsonRpcResult | ethers.JsonRpcError)[]>;
        contractAddresses(): {
            mainContract?: string | undefined;
            erc20BridgeL1?: string | undefined;
            erc20BridgeL2?: string | undefined;
            wethBridgeL1?: string | undefined;
            wethBridgeL2?: string | undefined;
        };
        _getBlockTag(blockTag?: ethers.BlockTag | undefined): string | Promise<string>;
        _wrapLog(value: any, network: ethers.Network): Log;
        _wrapBlock(value: any, network: ethers.Network): Block;
        _wrapTransactionResponse(value: any, network: ethers.Network): TransactionResponse;
        _wrapTransactionReceipt(value: any, network: ethers.Network): TransactionReceipt;
        getTransactionReceipt(txHash: string): Promise<TransactionReceipt>;
        getTransaction(txHash: string): Promise<TransactionResponse>;
        getBlock(blockHashOrBlockTag: ethers.BlockTag, includeTxs?: boolean | undefined): Promise<Block>;
        getLogs(filter: ethers.Filter | ethers.FilterByBlockHash): Promise<Log[]>;
        getBalance(address: string, blockTag?: ethers.BlockTag | undefined, tokenAddress?: string | undefined): Promise<bigint>;
        l2TokenAddress(token: string): Promise<string>;
        l1TokenAddress(token: string): Promise<string>;
        estimateGasL1(transaction: TransactionRequest): Promise<bigint>;
        estimateFee(transaction: TransactionRequest): Promise<Fee>;
        getGasPrice(): Promise<bigint>;
        getLogProof(txHash: ethers.BytesLike, index?: number | undefined): Promise<MessageProof | null>;
        getL1BatchBlockRange(l1BatchNumber: number): Promise<[number, number] | null>;
        getMainContractAddress(): Promise<string>;
        getTestnetPaymasterAddress(): Promise<string | null>;
        getDefaultBridgeAddresses(): Promise<{
            erc20L1: string | undefined;
            erc20L2: string | undefined;
            wethL1: string | undefined;
            wethL2: string | undefined;
        }>;
        getConfirmedTokens(start?: number, limit?: number): Promise<Token[]>;
        getAllAccountBalances(address: string): Promise<BalancesMap>;
        l1ChainId(): Promise<number>;
        getL1BatchNumber(): Promise<number>;
        getL1BatchDetails(number: number): Promise<BatchDetails>;
        getBlockDetails(number: number): Promise<BlockDetails>;
        getTransactionDetails(txHash: ethers.BytesLike): Promise<TransactionDetails>;
        getBytecodeByHash(bytecodeHash: ethers.BytesLike): Promise<Uint8Array>;
        getRawBlockTransactions(number: number): Promise<RawBlockTransaction[]>;
        getWithdrawTx(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<ethers.TransactionRequest>;
        estimateGasWithdraw(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getTransferTx(transaction: {
            to: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            token?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<ethers.TransactionRequest>;
        estimateGasTransfer(transaction: {
            to: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            token?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        newFilter(filter: ethers.Filter | ethers.FilterByBlockHash): Promise<bigint>;
        newBlockFilter(): Promise<bigint>;
        newPendingTransactionsFilter(): Promise<bigint>;
        getFilterChanges(idx: bigint): Promise<(string | Log)[]>;
        getTransactionStatus(txHash: string): Promise<TransactionStatus>;
        broadcastTransaction(signedTx: string): Promise<TransactionResponse>;
        getL2TransactionFromPriorityOp(l1TxResponse: ethers.TransactionResponse): Promise<TransactionResponse>;
        getPriorityOpResponse(l1TxResponse: ethers.TransactionResponse): Promise<PriorityOpResponse>;
        getContractAccountInfo(address: string): Promise<ContractAccountInfo>;
        estimateL1ToL2Execute(transaction: {
            contractAddress: string;
            calldata: string;
            caller?: string | undefined;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getRpcTransaction(tx: TransactionRequest): ethers.JsonRpcTransactionRequest;
        "__#17@#private": any;
        _getOption<K extends keyof ethers.JsonRpcApiProviderOptions>(key: K): ethers.JsonRpcApiProviderOptions[K];
        readonly _network: ethers.Network;
        _perform(req: ethers.PerformActionRequest): Promise<any>;
        _detectNetwork(): Promise<ethers.Network>;
        _start(): void;
        _waitUntilReady(): Promise<void>;
        _getSubscriber(sub: ethers.Subscription): ethers.Subscriber;
        readonly ready: boolean;
        getRpcRequest(req: ethers.PerformActionRequest): {
            method: string;
            args: any[];
        } | null;
        getRpcError(payload: ethers.JsonRpcPayload, _error: ethers.JsonRpcError): Error;
        send(method: string, params: any[] | Record<string, any>): Promise<any>;
        getSigner(address?: string | number | undefined): Promise<ethers.JsonRpcSigner>;
        listAccounts(): Promise<ethers.JsonRpcSigner[]>;
        destroy(): void;
        "__#14@#private": any;
        readonly pollingInterval: number;
        readonly provider: any;
        readonly plugins: ethers.AbstractProviderPlugin[];
        attachPlugin(plugin: ethers.AbstractProviderPlugin): any;
        getPlugin<T extends ethers.AbstractProviderPlugin = ethers.AbstractProviderPlugin>(name: string): T | null;
        disableCcipRead: boolean;
        ccipReadFetch(tx: ethers.PerformActionTransaction, calldata: string, urls: string[]): Promise<string | null>;
        getBlockNumber(): Promise<number>;
        _getAddress(address: ethers.AddressLike): string | Promise<string>;
        _getFilter(filter: ethers.Filter | ethers.FilterByBlockHash): ethers.PerformActionFilter | Promise<ethers.PerformActionFilter>;
        _getTransactionRequest(_request: ethers.TransactionRequest): ethers.PerformActionTransaction | Promise<ethers.PerformActionTransaction>;
        getNetwork(): Promise<ethers.Network>;
        getFeeData(): Promise<ethers.FeeData>;
        estimateGas(_tx: ethers.TransactionRequest): Promise<bigint>;
        call(_tx: ethers.TransactionRequest): Promise<string>;
        getTransactionCount(address: ethers.AddressLike, blockTag?: ethers.BlockTag | undefined): Promise<number>;
        getCode(address: ethers.AddressLike, blockTag?: ethers.BlockTag | undefined): Promise<string>;
        getStorage(address: ethers.AddressLike, _position: ethers.BigNumberish, blockTag?: ethers.BlockTag | undefined): Promise<string>;
        getTransactionResult(hash: string): Promise<string | null>;
        _getProvider(chainId: number): ethers.AbstractProvider;
        getResolver(name: string): Promise<ethers.EnsResolver | null>;
        getAvatar(name: string): Promise<string | null>;
        resolveName(name: string): Promise<string | null>;
        lookupAddress(address: string): Promise<string | null>;
        waitForTransaction(hash: string, _confirms?: number | null | undefined, timeout?: number | null | undefined): Promise<ethers.TransactionReceipt | null>;
        waitForBlock(blockTag?: ethers.BlockTag | undefined): Promise<ethers.Block>;
        _clearTimeout(timerId: number): void;
        _setTimeout(_func: () => void, timeout?: number | undefined): number;
        _forEachSubscriber(func: (s: ethers.Subscriber) => void): void;
        _recoverSubscriber(oldSub: ethers.Subscriber, newSub: ethers.Subscriber): void;
        on(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        once(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        emit(event: ethers.ProviderEvent, ...args: any[]): Promise<boolean>;
        listenerCount(event?: ethers.ProviderEvent | undefined): Promise<number>;
        listeners(event?: ethers.ProviderEvent | undefined): Promise<ethers.Listener[]>;
        off(event: ethers.ProviderEvent, listener?: ethers.Listener | undefined): Promise<any>;
        removeAllListeners(event?: ethers.ProviderEvent | undefined): Promise<any>;
        addListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        removeListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        readonly destroyed: boolean;
        paused: boolean;
        pause(dropWhilePaused?: boolean | undefined): void;
        resume(): void;
    };
} & typeof ethers.JsonRpcProvider;
export declare class Provider extends Provider_base {
    #private;
    protected _contractAddresses: {
        mainContract?: Address;
        erc20BridgeL1?: Address;
        erc20BridgeL2?: Address;
    };
    contractAddresses(): {
        mainContract?: Address;
        erc20BridgeL1?: Address;
        erc20BridgeL2?: Address;
    };
    constructor(url?: ethers.FetchRequest | string, network?: Networkish, options?: any);
    _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult>>;
    static getDefaultProvider(zksyncNetwork?: ZkSyncNetwork): Provider | undefined;
}
declare const BrowserProvider_base: {
    new (...args: any[]): {
        _send(payload: ethers.JsonRpcPayload | ethers.JsonRpcPayload[]): Promise<(ethers.JsonRpcResult | ethers.JsonRpcError)[]>;
        contractAddresses(): {
            mainContract?: string | undefined;
            erc20BridgeL1?: string | undefined;
            erc20BridgeL2?: string | undefined;
            wethBridgeL1?: string | undefined;
            wethBridgeL2?: string | undefined;
        };
        _getBlockTag(blockTag?: ethers.BlockTag | undefined): string | Promise<string>;
        _wrapLog(value: any, network: ethers.Network): Log;
        _wrapBlock(value: any, network: ethers.Network): Block;
        _wrapTransactionResponse(value: any, network: ethers.Network): TransactionResponse;
        _wrapTransactionReceipt(value: any, network: ethers.Network): TransactionReceipt;
        getTransactionReceipt(txHash: string): Promise<TransactionReceipt>;
        getTransaction(txHash: string): Promise<TransactionResponse>;
        getBlock(blockHashOrBlockTag: ethers.BlockTag, includeTxs?: boolean | undefined): Promise<Block>;
        getLogs(filter: ethers.Filter | ethers.FilterByBlockHash): Promise<Log[]>;
        getBalance(address: string, blockTag?: ethers.BlockTag | undefined, tokenAddress?: string | undefined): Promise<bigint>;
        l2TokenAddress(token: string): Promise<string>;
        l1TokenAddress(token: string): Promise<string>;
        estimateGasL1(transaction: TransactionRequest): Promise<bigint>;
        estimateFee(transaction: TransactionRequest): Promise<Fee>;
        getGasPrice(): Promise<bigint>;
        getLogProof(txHash: ethers.BytesLike, index?: number | undefined): Promise<MessageProof | null>;
        getL1BatchBlockRange(l1BatchNumber: number): Promise<[number, number] | null>;
        getMainContractAddress(): Promise<string>;
        getTestnetPaymasterAddress(): Promise<string | null>;
        getDefaultBridgeAddresses(): Promise<{
            erc20L1: string | undefined;
            erc20L2: string | undefined;
            wethL1: string | undefined;
            wethL2: string | undefined;
        }>;
        getConfirmedTokens(start?: number, limit?: number): Promise<Token[]>;
        getAllAccountBalances(address: string): Promise<BalancesMap>;
        l1ChainId(): Promise<number>;
        getL1BatchNumber(): Promise<number>;
        getL1BatchDetails(number: number): Promise<BatchDetails>;
        getBlockDetails(number: number): Promise<BlockDetails>;
        getTransactionDetails(txHash: ethers.BytesLike): Promise<TransactionDetails>;
        getBytecodeByHash(bytecodeHash: ethers.BytesLike): Promise<Uint8Array>;
        getRawBlockTransactions(number: number): Promise<RawBlockTransaction[]>;
        getWithdrawTx(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<ethers.TransactionRequest>;
        estimateGasWithdraw(transaction: {
            token: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            to?: string | undefined;
            bridgeAddress?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getTransferTx(transaction: {
            to: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            token?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<ethers.TransactionRequest>;
        estimateGasTransfer(transaction: {
            to: string;
            amount: ethers.BigNumberish;
            from?: string | undefined;
            token?: string | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        newFilter(filter: ethers.Filter | ethers.FilterByBlockHash): Promise<bigint>;
        newBlockFilter(): Promise<bigint>;
        newPendingTransactionsFilter(): Promise<bigint>;
        getFilterChanges(idx: bigint): Promise<(string | Log)[]>;
        getTransactionStatus(txHash: string): Promise<TransactionStatus>;
        broadcastTransaction(signedTx: string): Promise<TransactionResponse>;
        getL2TransactionFromPriorityOp(l1TxResponse: ethers.TransactionResponse): Promise<TransactionResponse>;
        getPriorityOpResponse(l1TxResponse: ethers.TransactionResponse): Promise<PriorityOpResponse>;
        getContractAccountInfo(address: string): Promise<ContractAccountInfo>;
        estimateL1ToL2Execute(transaction: {
            contractAddress: string;
            calldata: string;
            caller?: string | undefined;
            l2Value?: ethers.BigNumberish | undefined;
            factoryDeps?: ethers.BytesLike[] | undefined;
            gasPerPubdataByte?: ethers.BigNumberish | undefined;
            overrides?: ethers.Overrides | undefined;
        }): Promise<bigint>;
        getRpcTransaction(tx: TransactionRequest): ethers.JsonRpcTransactionRequest;
        "__#17@#private": any;
        _getOption<K extends keyof ethers.JsonRpcApiProviderOptions>(key: K): ethers.JsonRpcApiProviderOptions[K];
        readonly _network: ethers.Network;
        _perform(req: ethers.PerformActionRequest): Promise<any>;
        _detectNetwork(): Promise<ethers.Network>;
        _start(): void;
        _waitUntilReady(): Promise<void>;
        _getSubscriber(sub: ethers.Subscription): ethers.Subscriber;
        readonly ready: boolean;
        getRpcRequest(req: ethers.PerformActionRequest): {
            method: string;
            args: any[];
        } | null;
        getRpcError(payload: ethers.JsonRpcPayload, _error: ethers.JsonRpcError): Error;
        send(method: string, params: any[] | Record<string, any>): Promise<any>;
        getSigner(address?: string | number | undefined): Promise<ethers.JsonRpcSigner>;
        listAccounts(): Promise<ethers.JsonRpcSigner[]>;
        destroy(): void;
        "__#14@#private": any;
        readonly pollingInterval: number;
        readonly provider: any;
        readonly plugins: ethers.AbstractProviderPlugin[];
        attachPlugin(plugin: ethers.AbstractProviderPlugin): any;
        getPlugin<T extends ethers.AbstractProviderPlugin = ethers.AbstractProviderPlugin>(name: string): T | null;
        disableCcipRead: boolean;
        ccipReadFetch(tx: ethers.PerformActionTransaction, calldata: string, urls: string[]): Promise<string | null>;
        getBlockNumber(): Promise<number>;
        _getAddress(address: ethers.AddressLike): string | Promise<string>;
        _getFilter(filter: ethers.Filter | ethers.FilterByBlockHash): ethers.PerformActionFilter | Promise<ethers.PerformActionFilter>;
        _getTransactionRequest(_request: ethers.TransactionRequest): ethers.PerformActionTransaction | Promise<ethers.PerformActionTransaction>;
        getNetwork(): Promise<ethers.Network>;
        getFeeData(): Promise<ethers.FeeData>;
        estimateGas(_tx: ethers.TransactionRequest): Promise<bigint>;
        call(_tx: ethers.TransactionRequest): Promise<string>;
        getTransactionCount(address: ethers.AddressLike, blockTag?: ethers.BlockTag | undefined): Promise<number>;
        getCode(address: ethers.AddressLike, blockTag?: ethers.BlockTag | undefined): Promise<string>;
        getStorage(address: ethers.AddressLike, _position: ethers.BigNumberish, blockTag?: ethers.BlockTag | undefined): Promise<string>;
        getTransactionResult(hash: string): Promise<string | null>;
        _getProvider(chainId: number): ethers.AbstractProvider;
        getResolver(name: string): Promise<ethers.EnsResolver | null>;
        getAvatar(name: string): Promise<string | null>;
        resolveName(name: string): Promise<string | null>;
        lookupAddress(address: string): Promise<string | null>;
        waitForTransaction(hash: string, _confirms?: number | null | undefined, timeout?: number | null | undefined): Promise<ethers.TransactionReceipt | null>;
        waitForBlock(blockTag?: ethers.BlockTag | undefined): Promise<ethers.Block>;
        _clearTimeout(timerId: number): void;
        _setTimeout(_func: () => void, timeout?: number | undefined): number;
        _forEachSubscriber(func: (s: ethers.Subscriber) => void): void;
        _recoverSubscriber(oldSub: ethers.Subscriber, newSub: ethers.Subscriber): void;
        on(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        once(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        emit(event: ethers.ProviderEvent, ...args: any[]): Promise<boolean>;
        listenerCount(event?: ethers.ProviderEvent | undefined): Promise<number>;
        listeners(event?: ethers.ProviderEvent | undefined): Promise<ethers.Listener[]>;
        off(event: ethers.ProviderEvent, listener?: ethers.Listener | undefined): Promise<any>;
        removeAllListeners(event?: ethers.ProviderEvent | undefined): Promise<any>;
        addListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        removeListener(event: ethers.ProviderEvent, listener: ethers.Listener): Promise<any>;
        readonly destroyed: boolean;
        paused: boolean;
        pause(dropWhilePaused?: boolean | undefined): void;
        resume(): void;
    };
} & typeof ethers.BrowserProvider;
export declare class BrowserProvider extends BrowserProvider_base {
    #private;
    protected _contractAddresses: {
        mainContract?: Address;
        erc20BridgeL1?: Address;
        erc20BridgeL2?: Address;
    };
    contractAddresses(): {
        mainContract?: Address;
        erc20BridgeL1?: Address;
        erc20BridgeL2?: Address;
    };
    constructor(ethereum: Eip1193Provider, network?: Networkish);
    _send(payload: JsonRpcPayload | Array<JsonRpcPayload>): Promise<Array<JsonRpcResult | JsonRpcError>>;
    getRpcError(payload: JsonRpcPayload, error: JsonRpcError): Error;
    hasSigner(address: number | string): Promise<boolean>;
    getSigner(address?: number | string): Promise<Signer>;
    estimateGas(transaction: TransactionRequest): Promise<bigint>;
}
export {};
